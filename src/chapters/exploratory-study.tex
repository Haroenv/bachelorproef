% !TEX root = ../main.tex

\chapter{Exploratory study} % (fold)
\label{chp:exploratory_study}

\section{title}

\subsection{Yarn} % (fold)
\label{ssec:yarn}

Note: still need to convert to third person...

A way to discover all intricacies of an ecosystem is to use it in a lot of different ways

Before jumping into making a new library or improving an existing one, one should use it sufficiently. For that purpose my first task at Algolia was to use React InstantSearch in a (complex) production application, the website of Yarn~\cite{yarn-site}~.

Yarn is an open source package manager developed jointly by engineers at Facebook, Google and Tilde for the JavaScript ecosystem, based on the npm package manager. It allows for code to be easily shared among everyone in the world~\cite{yarn-site}~.

In both the npm and Yarn ecosystem code is shared in packages --- also called modules --- which all have a {\tt package.json} file that describes metadata on the package, together with all the code. Yarn and npm share the npm repository for having the packages of the ecosystem.

The Algolia team already worked on integrating Algolia search into the Yarn website~\cite{yarn-pr-add-algolia}~. Since the very beginning of 2017, itâ€™s possible to look up packages at a very impressive speed at \href{https://yarnpkg.com/search}{yarnpkg.com/search}. Making small fixes in the codebase\footnote{\href{https://github.com/yarnpkg/website/pulls/208}{yarnpkg/website\#208}, \href{https://github.com/yarnpkg/website/pulls/210}{yarnpkg/website\#210}, \href{https://github.com/yarnpkg/website/pulls211}{yarnpkg/website\#211} and \href{https://github.com/yarnpkg/website/pulls/335}{yarnpkg/website\#335}} in the past made the project and research on further improving that experience proved to be a very exciting endeavour.

The metadata in the npm and Yarn repository is being enriched by an indexing process\cite{npm-search} that takes in packages in the npm repository, and joins that together with places that have more information, like GitHub, and the amount of monthly downloads per package.

This 

In the week before I arrived in Paris, some of the team members (Sylvain Utard, Kevin Granger and Vincent Voyer) went to the Facebook offices in London to explore the possibilities of making a detail page for the search, and integrating it even more into the website.

The Yarn project is evolving from having metadata from the npm packages in an index, used only on the Yarn website, to a free to use API, which can make great search available to everyone who wants to make something for the ecosystem. The first other website that will use this data will be the online code editor \href{https://codesandbox.io}{CodeSandbox.io} for the interface where someone can add a dependency to a project. A lot of other integrations are expected in the time coming after this service will be formally announced.

%% url

% section yarn (end)
\section{What is even wrong with the Helper} % (fold)
\label{sec:what_is_even_wrong_with_the_helper}

There have been several phases in the life of Algolia regarding building user interfaces on the web. In short, first there was only the REST API\@. Then tutorials were written on how to use Algolia to build user interfaces using jQuery, moment.js etc. After that the algoliasearch-helper~\cite{algolia-js-helper} was written to avoid boilerplate. And most recently InstantSearch.js~\cite{instantsearch-js} and React InstantSearch~\cite{react-instantsearch} were launched.

This evolution makes for three distinct phases in how state has been handled, based on which library is used.

\subsection{Algolia JS client} % (fold)
\label{sub:algolia_js_client}

When Algolia pivoted in 2013 to a SaaS product~\cite{algolia-blog-saas}, it had support~\cite{algolia-blog-lauch} for six languages out of the box. JavaScript has always been important because of the focus on speed that Algolia has.

There are two major options to make a search experience. The first is to send a request from the frontend to the search service, where a JSON response is returned, which then is uses to render results in client side code. The other is sending that same request via a form on an application-specific backend, and constructing the results there, and eventually sending a completely new page back as a result to the user's query.

Algolia has a preference for clients to construct the results on the frontend, mostly because it's a lot faster. Algolia has infrastructure~\cite{algolia-infra} all around the world, and thus having an extra roundtrip to wherever the backend of a client is, can take hundreds of milliseconds more. Since search seems slow as soon as the timeout takes more than 50ms, every millisecond matters.

The JS client~\cite{algolia-js-client} is the lowest useful level of abstraction, and handles things like retry strategies, dropped requests, dynamic routing based on location and request fallbacks. Because it originally was the only way to query Algolia, it also supports setting individual parameters before searching.

When using just the JS client, it can be noticed that all state should be handled inside the application code. That means keeping track whether a certain refinement has been set and unset, and keeping this consistent within the application code. Furthermore, the application needs to be aware when Algolia should be queried, and then handling all of the incoming results, dealing with out-of-order responses etc.

\begin{figure}[H]
\label{figure:js-client-state}
  \centering
  \includegraphics[width=0.6\textwidth, height=0.2\textheight, draft]{../assets/js-client-state.pdf}
  \caption{Handling state with the JS client}
\end{figure}

% subsection algolia_js_client (end)

\subsection{Algolia JS Helper} % (fold)
\label{sub:algolia_js_helper}

Before being a separate concept, the ``Helper'' was an integral part of the JS API client~\cite{algolia-blog-js-client}~. In 2015 it was moved out as a standalone library with as its main feature handling state of a search experience.

This means that when making a search experience, a new instance --- further called \emph{the} helper for that view --- of the Helper is created. When being initialized it creates a bond with a JS client instance, to be used for sending the API calls to the servers.

This helper exposes functions to modify the current state. It has three kinds of those functions

\begin{enumerate}
  \item idk %%
\end{enumerate}

\begin{figure}[H]
\label{figure:js-helper-state}
  \centering
  \includegraphics[width=0.6\textwidth]{../assets/helper-cycle.pdf}
  \caption{Handling state with the JS Helper\cite{js-helper-concepts}}
\end{figure}

It also handles the ``Hierarchical faceting''\cite{hierarchical-faceting}~. Hierarchical faceting %%

% subsection algolia_js_helper (end)

\subsection{InstantSearch.js} % (fold)
\label{sub:instantsearch_js}

rely on helper, expose it. Problem: very hard to make new components because you don't know how the helper works, and there's only a carte blanche component. %%

\begin{figure}[H]
\label{figure:is-js-state}
  \centering
  \includegraphics[width=0.6\textwidth, height=0.2\textheight, draft]{../assets/is-js-state.pdf}
  \caption{Handling state with InstantSearch.js v1}
\end{figure}

\subsubsection{Connectors} % (fold)
\label{ssub:instantsearch_js_connectors}

Connectors happened in v2 of instantsearch
-> expose each of the widgets cleanly
-> I helped in the design + implem %%

% subsubsection instantsearch_js_connectors (end)

% subsection instantsearch_js (end)

\subsection{React InstantSearch} % (fold)
\label{sub:react_instantearch}

Add a layer of state on top of the helper. Good because it hides the helper in {\tt connectors}. Problem: helper is still kinda visible but not really and that causes wrong expectations %%

\begin{figure}[H]
\label{figure:is-react-state}
  \centering
  \includegraphics[width=0.6\textwidth, height=0.2\textheight, draft]{../assets/is-react-state.pdf}
  \caption{Handling state with React InstantSearch}
\end{figure}

RIS also has connectors, they came out at release, not v2, repeat a bit the info here, but don't over-repeat. %%

% subsection react_instantearch (end)

\subsection{The future} % (fold)
\label{sub:the_future}

No more using helper, mapping attribute/component state to algolia state directly. %%

\begin{figure}[H]
\label{figure:is-core-state}
  \centering
  \includegraphics[width=0.6\textwidth, height=0.2\textheight, draft]{../assets/is-core-state.pdf}
  \caption{Handling state with the InstantSearch Core}
\end{figure}

% subsection the_future (end)

% section what_is_even_wrong_with_the_helper (end)
